<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>비동기 프로그래밍의 기초: Async, Await, Future, 그리고 Stream - The Rust Programming Language - Async</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language - Async</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="비동기-프로그래밍의-기초-async-await-future-그리고-stream"><a class="header" href="#비동기-프로그래밍의-기초-async-await-future-그리고-stream">비동기 프로그래밍의 기초: Async, Await, Future, 그리고 Stream</a></h2>
<p>많은 컴퓨터 작업은 완료까지 시간이 오래 걸릴 수 있습니다. 이러한 오래 걸리는 작업을 기다리는 동안 다른 일을 할 수 있다면 좋겠죠. 현대 컴퓨터는 한 번에 둘 이상의 작업을 처리할 수 있는 두 가지 기법, 즉 병렬성과 동시성을 제공합니다. 하지만 병렬 또는 동시 작업을 포함하는 프로그램을 작성하기 시작하면, 곧 <em>비동기 프로그래밍</em> 특유의 새로운 문제에 직면하게 됩니다. 비동기 프로그래밍에서는 작업이 시작된 순서대로 순차적으로 끝나지 않을 수 있기 때문입니다. 이 장에서는 16장에서 다룬 스레드를 활용한 병렬성과 동시성에 기반하여, 비동기 프로그래밍의 또 다른 접근법을 소개합니다. 여기에는 Rust의 Future, Stream, 이를 지원하는 <code>async</code>와 <code>await</code> 문법, 그리고 비동기 작업을 관리하고 조율하는 도구들이 포함됩니다.</p>
<p>예를 들어 생각해봅시다. 가족 모임 영상을 편집해서 내보내는 작업을 하고 있다고 가정해 보세요. 이 작업은 몇 분에서 몇 시간까지 걸릴 수 있습니다. 영상 내보내기는 가능한 모든 CPU와 GPU 자원을 사용하려고 할 것입니다. 만약 CPU 코어가 하나뿐이고, 운영체제가 내보내기 작업이 끝날 때까지 그 작업을 멈추지 않고 <em>동기적으로</em> 실행한다면, 그 작업이 진행되는 동안 컴퓨터에서 다른 어떤 일도 할 수 없을 것입니다. 꽤 답답한 경험이겠죠. 다행히도, 컴퓨터의 운영체제는 내보내기 작업을 눈에 띄지 않게 자주 중단시켜서, 동시에 다른 작업도 할 수 있도록 해줍니다.</p>
<p>이제 다른 사람이 공유한 영상을 다운로드한다고 가정해봅시다. 이 작업 역시 시간이 걸릴 수 있지만, CPU를 많이 사용하지는 않습니다. 이 경우에는 CPU가 네트워크로부터 데이터가 도착하기를 기다려야 합니다. 데이터가 도착하기 시작하면 바로 읽을 수 있지만, 모든 데이터가 도착하는 데에는 시간이 걸릴 수 있습니다. 영상이 매우 크다면, 모든 데이터를 불러오는 데 최소 1~2초가 걸릴 수도 있습니다. 이 정도 시간은 현대 프로세서에게는 매우 긴 시간입니다. 현대 프로세서는 1초에 수십억 번의 연산을 수행할 수 있기 때문이죠. 이 경우에도 운영체제는 네트워크 호출이 끝나기를 기다리는 동안, 눈에 띄지 않게 프로그램을 중단시켜 CPU가 다른 작업을 수행할 수 있도록 해줍니다.</p>
<p>영상 내보내기 작업은 <em>CPU 바운드</em> 또는 <em>연산 바운드</em> 작업의 예시입니다. 이 작업은 컴퓨터의 CPU나 GPU가 데이터를 처리할 수 있는 속도, 그리고 그 연산 자원을 얼마나 할당할 수 있는지에 의해 제한됩니다. 반면, 영상 다운로드는 <em>IO 바운드</em> 작업의 예시입니다. 이 작업은 컴퓨터의 <em>입출력</em> 속도에 의해 제한되며, 네트워크를 통해 데이터를 전송할 수 있는 속도가 곧 작업의 최대 속도가 됩니다.</p>
<p>이 두 예시 모두에서, 운영체제의 보이지 않는 인터럽트는 일종의 동시성을 제공합니다. 하지만 이러한 동시성은 전체 프로그램 수준에서만 발생합니다. 즉, 운영체제가 한 프로그램을 잠시 멈추고 다른 프로그램이 작업을 수행할 수 있도록 하는 것이죠. 하지만 많은 경우, 우리는 운영체제보다 훨씬 더 세밀한 수준에서 우리 프로그램을 이해하고 있기 때문에, 운영체제가 알아차릴 수 없는 동시성의 기회를 직접 찾아낼 수 있습니다.</p>
<p>예를 들어, 파일 다운로드를 관리하는 도구를 만든다고 가정해봅시다. 하나의 다운로드를 시작해도 UI가 멈추지 않아야 하고, 사용자는 동시에 여러 개의 다운로드를 시작할 수 있어야 합니다. 하지만 네트워크와 상호작용하는 많은 운영체제 API는 <em>블로킹</em> 방식입니다. 즉, 처리 중인 데이터가 완전히 준비될 때까지 프로그램의 진행을 멈추게 됩니다.</p>
<blockquote>
<p>참고: 사실 따지고 보면 <em>대부분의</em> 함수 호출이 이런 식으로 동작합니다. 하지만 일반적으로 <em>블로킹</em> 이라는 용어는 파일, 네트워크, 또는 컴퓨터의 다른 자원과 상호작용하는 함수 호출에 사용됩니다. 왜냐하면 이런 경우에야말로 개별 프로그램이 해당 작업이 <em>논블로킹</em> 으로 동작할 때 이점을 얻을 수 있기 때문입니다.</p>
</blockquote>
<p>메인 스레드를 블로킹하지 않으려면 파일마다 별도의 스레드를 생성해서 다운로드하도록 할 수도 있습니다. 하지만 이런 방식은 스레드의 오버헤드가 점점 문제가 될 수 있습니다. 애초에 호출 자체가 블로킹되지 않는 것이 더 바람직합니다. 또한, 블로킹 코드에서처럼 직관적인 방식으로 코드를 작성할 수 있다면 더 좋겠죠. 예를 들어 아래와 같이 말입니다:</p>
<pre><code class="language-rust ignore does_not_compile">let data = fetch_data_from(url).await;
println!("{data}");</code></pre>
<p>바로 이것이 Rust의 <em>async</em> (비동기) 추상화가 제공하는 기능입니다. 이 장에서는 async에 대해 다음과 같은 내용을 다룹니다:</p>
<ul>
<li>Rust의 <code>async</code>와 <code>await</code> 문법 사용법</li>
<li>16장에서 살펴본 문제들을 async 모델로 어떻게 해결할 수 있는지</li>
<li>멀티스레딩과 async가 어떻게 상호보완적인 해법을 제공하며, 많은 경우 이 둘을 결합할 수 있는지</li>
</ul>
<p>하지만 실제로 async가 어떻게 동작하는지 살펴보기 전에, 먼저 병렬성과 동시성의 차이점에 대해 간단히 짚고 넘어가겠습니다.</p>
<h3 id="병렬성과-동시성"><a class="header" href="#병렬성과-동시성">병렬성과 동시성</a></h3>
<p>지금까지는 병렬성과 동시성을 거의 같은 의미로 다뤘지만, 이제부터는 이 둘을 좀 더 정확하게 구분할 필요가 있습니다. 앞으로 실제로 코드를 작성하면서 그 차이가 드러나기 때문입니다.</p>
<p>소프트웨어 프로젝트에서 팀이 작업을 분담하는 여러 가지 방법을 생각해봅시다. 한 명에게 여러 작업을 맡길 수도 있고, 각 팀원에게 하나씩 할당할 수도 있으며, 이 두 가지 방식을 섞어서 사용할 수도 있습니다.</p>
<p>한 사람이 여러 작업을 동시에 끝내지 않고 번갈아가며 진행하는 경우, 이것이 바로 <em>동시성</em> 입니다. 예를 들어, 두 개의 서로 다른 프로젝트를 컴퓨터에 내려받아 작업하다가 한 프로젝트에서 막히거나 지루해지면 다른 프로젝트로 전환하는 상황을 생각해볼 수 있습니다. 한 사람이기 때문에 두 작업을 정확히 동시에 진행할 수는 없지만, 번갈아가며 한 번에 하나씩 작업을 진행할 수는 있습니다. 즉, 멀티태스킹을 통해 한 작업에서 다른 작업으로 전환하면서 조금씩 진전을 내는 것이죠(아래 Figure 17-1 참고).</p>
<figure>
<img src="img/trpl17-01.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to B1, B1 to A2, A2 to B2, B2 to A3, A3 to A4, and A4 to B3. The arrows between the subtasks cross the boxes between Task A and Task B." />
<figcaption>Figure 17-1: 작업 A와 작업 B 사이를 번갈아가며 전환하는 동시적 워크플로우</figcaption>
</figure>
팀이 여러 작업을 각 팀원에게 하나씩 나누어 맡기고, 각자가 자신의 작업을 독립적으로 진행한다면 이것이 바로 _병렬성_ 입니다. 팀의 모든 구성원이 동시에 각자의 작업을 진행할 수 있습니다(아래 Figure 17-2 참고).
<figure>
<img src="img/trpl17-02.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to A2, A2 to A3, A3 to A4, B1 to B2, and B2 to B3. No arrows cross between the boxes for Task A and Task B." />
<figcaption>Figure 17-2: 작업 A와 작업 B가 독립적으로 동시에 진행되는 병렬적 워크플로우</figcaption>
</figure>
<p>이러한 워크플로우 모두에서, 서로 다른 작업들 사이의 조율이 필요할 수 있습니다. 처음에는 한 사람에게 맡긴 작업이 다른 사람의 작업과 완전히 독립적이라고 <em>생각했을</em> 수도 있지만, 실제로는 팀의 다른 사람이 자신의 작업을 먼저 끝내야만 진행할 수 있는 경우도 있습니다. 일부 작업은 병렬로 처리할 수 있지만, 일부 작업은 실제로 <em>직렬적(serial)</em> 입니다. 즉, 반드시 순서대로, 하나씩 차례로만 진행될 수 있다는 뜻입니다(Figure 17-3 참고).</p>
<figure>
<img src="img/trpl17-03.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to A2, A2 to a pair of thick vertical lines like a “pause” symbol, from that symbol to A3, B1 to B2, B2 to B3, which is below that symbol, B3 to A3, and B3 to B4." />
<figcaption>Figure 17-3: 작업 A와 작업 B가 독립적으로 진행되다가, 작업 A3이 작업 B3의 결과를 기다리며 병렬성과 직렬 처리가 혼합된 워크플로우</figcaption>
</figure>
<p>마찬가지로, 자신의 작업 중 하나가 또 다른 자신의 작업에 의존한다는 사실을 깨달을 수도 있습니다. 이 경우에도 동시적으로 진행하던 작업이 직렬적으로 바뀌게 됩니다.</p>
<p>병렬성과 동시성은 서로 교차하기도 합니다. 만약 동료가 내가 맡은 작업이 끝나야만 자신의 작업을 진행할 수 있다면, 나는 아마도 그 작업에 모든 노력을 집중해 동료의 진행을 “언블록”하려 할 것입니다. 이때는 더 이상 병렬로도, 동시적으로도 작업할 수 없게 됩니다.</p>
<p>이러한 기본적인 역학은 소프트웨어와 하드웨어에서도 동일하게 적용됩니다. 단일 CPU 코어를 가진 컴퓨터에서는 한 번에 하나의 작업만 처리할 수 있지만, 여전히 동시적으로 작업할 수 있습니다. 스레드, 프로세스, async와 같은 도구를 사용하면, 컴퓨터는 한 작업을 잠시 멈추고 다른 작업으로 전환한 뒤, 다시 처음 작업으로 돌아올 수 있습니다. 여러 CPU 코어가 있다면, 병렬로 작업도 가능합니다. 한 코어가 한 작업을 처리하는 동안, 다른 코어는 완전히 별개의 작업을 동시에 처리할 수 있습니다.</p>
<p>Rust에서 async를 사용할 때는 항상 동시성을 다루게 됩니다. 하드웨어, 운영체제, 그리고 사용하는 async 런타임(이에 대해서는 곧 설명합니다)에 따라, 이러한 동시성이 내부적으로 병렬성을 활용할 수도 있습니다.</p>
<p>이제 Rust에서 비동기 프로그래밍이 실제로 어떻게 동작하는지 살펴보겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-01-futures-and-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
